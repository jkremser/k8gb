/*
Copyright 2021 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/
package controllers

import (
	"fmt"
	"sort"
	"strings"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	externaldns "sigs.k8s.io/external-dns/endpoint"
)

func sortTargets(targets []string) {
	sort.Slice(targets, func(i, j int) bool {
		return targets[i] < targets[j]
	})
}

func (r *GslbReconciler) gslbDNSEndpoint(gslb *k8gbv1beta1.Gslb) (*externaldns.DNSEndpoint, error) {
	var gslbHosts []*externaldns.Endpoint
	var ttl = externaldns.TTL(gslb.Spec.Strategy.DNSTtlSeconds)

	serviceHealth, err := r.getServiceHealthStatus(gslb)
	if err != nil {
		return nil, err
	}

	localTargets, err := r.DNSProvider.GslbIngressExposedIPs(gslb)
	if err != nil {
		return nil, err
	}

	for ingressHost, health := range serviceHealth {
		var finalTargets []string

		if !strings.Contains(ingressHost, r.Config.EdgeDNSZone) {
			return nil, fmt.Errorf("ingress host %s does not match delegated zone %s", ingressHost, r.Config.EdgeDNSZone)
		}

		isPrimary := gslb.Spec.Strategy.PrimaryGeoTag == r.Config.ClusterGeoTag
		isHealthy := health == k8gbv1beta1.Healthy

		if isHealthy {
			localTargetsHost := fmt.Sprintf("localtargets-%s", ingressHost)
			dnsRecord := &externaldns.Endpoint{
				DNSName:    localTargetsHost,
				RecordTTL:  ttl,
				RecordType: "A",
				Targets:    localTargets,
			}
			gslbHosts = append(gslbHosts, dnsRecord)
		}

		finalTargets = r.resolveFinalTargets(gslb, ingressHost, localTargets, isPrimary, isHealthy)

		r.updateMetrics(gslb, isPrimary, health, finalTargets)
		log.Info().
			Str("gslb", gslb.Name).
			Str("targets", fmt.Sprintf("%v", finalTargets)).
			Msg("Final target list")

		if len(finalTargets) > 0 {
			dnsRecord := &externaldns.Endpoint{
				DNSName:    ingressHost,
				RecordTTL:  ttl,
				RecordType: "A",
				Targets:    finalTargets,
				Labels: externaldns.Labels{
					"strategy": gslb.Spec.Strategy.Type,
				},
			}
			gslbHosts = append(gslbHosts, dnsRecord)
		}
	}
	dnsEndpointSpec := externaldns.DNSEndpointSpec{
		Endpoints: gslbHosts,
	}

	dnsEndpoint := &externaldns.DNSEndpoint{
		ObjectMeta: metav1.ObjectMeta{
			Name:        gslb.Name,
			Namespace:   gslb.Namespace,
			Annotations: map[string]string{"k8gb.absa.oss/dnstype": "local"},
			Labels:      map[string]string{"k8gb.absa.oss/dnstype": "local"},
		},
		Spec: dnsEndpointSpec,
	}

	err = controllerutil.SetControllerReference(gslb, dnsEndpoint, r.Scheme)
	if err != nil {
		return nil, err
	}
	return dnsEndpoint, err
}

func (r *GslbReconciler) resolveFinalTargets(gslb *k8gbv1beta1.Gslb, host string, localTargets []string, isPrimary bool, isHealthy bool) []string {
	allExternalClusterNSNames := r.Config.GetExternalClusterNSNames()
	switch gslb.Spec.Strategy.Type {
	case roundRobinStrategy, geoStrategy:
		externalTargets := r.DNSProvider.GetExternalTargets(host, allExternalClusterNSNames)
		if len(externalTargets) > 0 {
			sortTargets(externalTargets)
			return append(localTargets, externalTargets...)
		}
		log.Info().
			Str("host", host).
			Msg("No external targets have been found for host")
	case failoverStrategy:
		if isPrimary && isHealthy {
			// If cluster is Primary and Healthy return only own targets
			return localTargets
		}
		orderedTags := gslb.Spec.Strategy.FailoverOrder
		log.Info().
			Str("gslb", gslb.Name).
			Str("cluster", gslb.Spec.Strategy.PrimaryGeoTag).
			Str("localTargets", fmt.Sprintf("%v", localTargets)).
			Str("workload", k8gbv1beta1.Unhealthy.String()).
			Str("failoverOrder", strings.Join(orderedTags, ", ")).
			Msg("Executing failover strategy: finding proper cluster to take it over")

		// each cluster is responsible for updating its the DNS A records for localtargets-{host} based on the readiness probes, so let's find the
		// first one from the list that have it non-empty
		lHost := fmt.Sprintf("localtargets-%s", host)
		for _, tag := range orderedTags {
			externalTargets := r.DNSProvider.GetExternalTargets(lHost, map[string]string{
				tag: allExternalClusterNSNames[tag],
			})
			if len(externalTargets) > 0 {
				sortTargets(externalTargets)
				log.Info().
					Str("host", host).
					Str("clusterTag", tag).
					Msg("Executing failover strategy: suitable cluster on which the host is alive has been found")
				return externalTargets
			}
			log.Info().
				Str("host", host).
				Str("clusterTag", tag).
				Str("failoverOrder", strings.Join(orderedTags, ", ")).
				Msg("No external targets have been found for host, trying next cluster tag..")
		}

		log.Info().
			Str("host", host).
			Msg("No external targets have been found for host, on all clusters. There is no cluster to fail over.")
		return []string{}
	}
	if isHealthy {
		return localTargets
	}
	return []string{}
}

func (r *GslbReconciler) updateMetrics(gslb *k8gbv1beta1.Gslb, isPrimary bool, isHealthy k8gbv1beta1.HealthStatus, finalTargets []string) {
	switch gslb.Spec.Strategy.Type {
	case roundRobinStrategy:
		m.UpdateRoundrobinStatus(gslb, isHealthy, finalTargets)
	case geoStrategy:
		m.UpdateGeoIPStatus(gslb, isHealthy, finalTargets)
	case failoverStrategy:
		m.UpdateFailoverStatus(gslb, isPrimary, isHealthy, finalTargets)
	}
}
